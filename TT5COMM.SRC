


		;THIS IS A PROGRAM FOR THE TT5
		;TERMINAL TO COMMUNICATE WITH THE 
		;PROLOG 7842-1 Z80 CPU CARD.

		;       IN THE MAIN PROGRAM THAT USES THIS MODULE IT WILL
		;  NEED TO CALL CHREC.
		;  	THIS WILL CALL THE ROUTINE AND CHECK IF THE RECEIVED
		;  FLAG IS SET, AND IF SO WILL PERFORM THE PROCESS.  THE 
		;  RECEIVED FLAG WILL BE SET WHEN INFORMATION IS COMING IN
		;  FROM THE TT5 TERMINAL.
		;	THE PROGRAM IS MADE TRANSPARENT IN THAT IF THE 
		;  TRANSMIT BUFFER FILLS, A FLAG IN THE SIO IS SET.
		;  THE LOCATION WILL BE PLACED IN A JUMP REGISTER SO
		;  THE NEXT TIME THE PROGRAM IS CALLED, AND IF THE TRANSMIT
		;  BUFFER FLAG IS RESET, THE LOCATION WILL BE RETURNED TO AND
		;  THE DESIRED TASK WILL CONTINUE.	
		;	IT IS RECOMMENDED THAT THE PROGRAM BE CALLED ON
		;  A TIMED BASIS SUCH AS EVERY 10mS.


	NAME 	COMM

	GLOBAL	VAL1,VAL2,CHREC,SIOI,VAL10
	EXTRN	DISPLAY,DISPLAYC,ESIRLY

	ORG	1000H

	;*********************MACRO DEFINITIONS******************

WRITE		MACRO	#X1,#X2,#X3,#X4

	LD	HL,W#$YM
	IFC	#X4,C
	CALL	DISPLAYC
	ELSE
	CALL	DISPLAY
	ENDC
	JP	W2#$YM
W#$YM	IFC	#X3,C
	DB	12-((W2#$YM-W3#$YM)/2)+((#X2-1)*24)

	ELSE
	DB	(#X3-1)+((#X2-1)*24)
	ENDC
W3#$YM	DEFM	'#X1'
W2#$YM	NOP
	ENDM

		;****************************************************



TT5MEM	EQU	0A100H			;RAM LOCATION FOR TESTMARK PROGRAM.
VAL1	EQU	TT5MEM+04H		;OUTPUT VALUE MEMORY LOCATION.
VAL2	EQU	TT5MEM+08H		;LOOP BIT MEMORY LOCATION.
VAL3	EQU	TT5MEM+0CH		;CHANGE CONTENTS MEMORY.	
VAL4	EQU	TT5MEM+10H		;CHANGE CONTENTS MEMORY.
VAL5	EQU	TT5MEM+14H		;CHANGE CONTENTS MEMORY.
VAL6	EQU	TT5MEM+18H		;CHANGE MEMORY LOCATION MEMORY.
VAL7	EQU	TT5MEM+1CH		;PROGRAM TT5 MEMORY LOCATION.
VAL8	EQU	TT5MEM+20H		;INCREMENT OR DECREMENT REGISTER.
VAL9	EQU	TT5MEM+24H		;INCREMENT OR DECTRMENT REGISTER.
VAL10	EQU	TT5MEM+28H
JUMP1	EQU	TT5MEM+2CH		;POLL LOOP MEMORY LOCATION.
JUMP2	EQU	TT5MEM+30H		;WAIT LOOP MEMORY LOCATION.
LOCA	EQU	TT5MEM+34H		;LOCATION OF WHERE TO JUMP FROM LOOP.
COUNT	EQU	TT5MEM+38H		;LOCATION TO SAVE THE OUTPUT COUNT.
SVBC	EQU	TT5MEM+3CH		;LOCATION TO SAVE THE BC VALUE.
BITV	EQU	TT5MEM+40H		;LOCATION FOR PORT READ FUNCTION.
PORV	EQU	TT5MEM+44H		;LOCATION FOR PORT READ FUNCTION.
PTPL	EQU	TT5MEM+48H		;PORT VIEW POLL LOCA MEMORY REGISTER.
JUMP3	EQU	TT5MEM+4CH		;POLLA LOOP MEMORY LOCATION.
TOGV	EQU	TT5MEM+50H		;PORT BIT TOGGLE MEMORY LOCATION.
SPOT	EQU	TT5MEM+54H		;INPUT VALUE STORAGE LOCATION

CHREC:	LD DE,(SVBC)	;RESTORE THE CONTENTS OF THE BC REG PAIR.
	LD B,D
	LD C,E
	LD A,(VAL2)	;CHECK IF IN THE POLL LOOP.
	BIT 0,A
	JP Z,FST
	LD HL,(JUMP1)	;JUMP TO PRESET LOCATION.
	JP (HL)
FST:	LD A,(VAL2)	;CHECK IF IN THE WAIT LOOP.
	BIT 1,A
	JP Z,SND
	LD HL,(JUMP2)	;JUMP TO PRESET LOCATION.
	JP (HL)
SND:	LD A,(VAL2)	;CHECK IF IN THE POLLA LOOP FOR PORT MONITOR.
	BIT 4,A
	JP Z,TRD
	LD HL,(JUMP3)	;JUMP TO PRESET LOCATION.
	JP (HL)
TRD:	LD A,00H
	OUT 0F5H,A	;POINT WR0 AT RR0.
	IN A,0F5H
	BIT 0,A		;SEE IF THERE IS VALUE TO READ.
	JP NZ,NXT
	RET
NXT:	IN A,0F4H	;INPUT THE TT5 DATA VALUE.
	LD (SPOT),A	;STORE THE VALUE IN REGISTER FOR LATER COMPARISONS
	CP 18H		;SEE IF THE COMMAND IS A CLEAR REQUEST
	JP Z,CLEAR
	LD A,(ESIRLY)
	CP 00H		;SEE IF ANY ERROR FLAGS ARE SET
	JP NZ,ERDIS
	LD A,(SPOT)
	CP 61H		;SEE IF THE VALUE IS HELP REQUEST.
	JP Z,HELP
	CP 62H		;CHECK IF TOGGLING PORT VALUE BITS.
	JP Z,TOGGLE
	CP 63H		;CHECK IF MEMORY LOCATION VIEW REQUEST.
	JP Z,MVIEW
	CP 65H		;CHECK IF VIEWING PORT LOCATION.
	JP Z,PTVIEW	
	CP 64H		;CHECK IF CHANGE MEMORY.
	JP Z,CHVAL
	CP 66H		;CHECK IF CHANGE PORT VALUE.
	JP Z,PCHG
	CP 2AH		;CHECK IF PROGRAMMING TT5 BY PRESSING ASTERIK.
	JP Z,PRTT5
	OUT 0F4H,A	;ECHO BACK VALUE AND RETURN.
	LD D,B
	LD E,C
	LD (SVBC),DE	;STORE THE CONTENTS OF THE BC REG PAIR.
	RET

ERDIS:	LD A,(ESIRLY)
	BIT	0,A		;CHECK IF GO AND LO ARE BOTH SET
	JP	NZ,GOLOER
	BIT	1,A		;CHECK IF GO AND HI ARE BOTH SET
	JP	NZ,GOHIER
	BIT	2,A		;CHECK IF ALL RELAYS ARE CLOSED
	JP	NZ,ALLER
	BIT	3,A		;CHECK IF NO RELAYS ARE CLOSED
	JP	NZ,NONER
	BIT	4,A		;CHECK IF HI AND LO ARE BOTH SET
	JP	NZ,HILOER
	RET

HILOER:	WRITE	'PART TESTED HIGH AND LOW',1,C,C
	WRITE	'CHECK COMPARATOR SETTING',2,C
	RET

NONER:	WRITE	'TEST RESULTS NOT PRESENT',1,C,C
	WRITE	'CHECK COMPARATOR POWER',2,C
	RET

ALLER:	WRITE	'ALL TEST RESULTS PRESENT',1,C,C
	WRITE	'CHECK COMPARATOR',2,C
	RET

GOHIER:	WRITE	'PART TESTS GOOD AND HIGH',1,C,C
	WRITE	'CHECK COMPARATOR',2,C
	RET

GOLOER:	WRITE	'PART TESTED GOOD AND LOW',1,C,C
	WRITE	'CHECK COMPARATOR',2,C
	RET



SIOI:	LD A,18H	;RESET THE SIO REGISTERS.
	OUT 0F5H,A	
	LD A,14H	;POINT TO WR4.
	OUT 0F5H,A
	LD A,07H	;CHANGE 0 TO 4 FOR 2400 OR LESS BAUD. ********
	OUT 0F5H,A
	LD A,13H	;POINT TO WR3.
	OUT 0F5H,A
	LD A,0C3H
	OUT 0F5H,A
	LD A,15H	;POINT TO WR5.
	OUT 0F5H,A
	LD A,6AH
	OUT 0F5H,A
	LD A,11H	;POINT TO WR1.
	OUT 0F5H,A
	LD A,00H
	OUT 0F5H,A
	RET

CLEAR:	LD A,0CH
	OUT 0F4H,A
	LD A,00H	;CLEAR THE LOCATION FLAGS
	LD (VAL2),A
	LD (TOGV),A
	RET

WAITL:	IN A,0F5H	;CHECK TO SEE IF TRANSMIT READY BIT SET.
	BIT 2,A
	JP NZ,WAITL1
	LD DE,WAITL
	LD (JUMP2),DE	;IF NOT READY TO TRANSMIT THEN SET THE LOOP BIT
	LD A,(VAL2)	;AND RETURN TO MAIN PROGRAM.
	SET 1,A
	LD (VAL2),A
	LD D,B		;SAVE THE REGISTER PAIR BC CONTENTS 
	LD E,C
	LD (SVBC),DE
	RET
WAITL1:	LD A,(VAL2)	;WHEN READY TO TRANSMIT NEXT BIT RESET THE LOOP BIT.
	RES 1,A
	LD (VAL2),A
	LD HL,(LOCA)	;JUMP BACK TO PRESET LOCATION.
	JP (HL)


HELP:	LD A,0CH	;CLEAR SCREEN.
	OUT 0F4H,A
	LD DE,HELP1
	LD (LOCA),DE
	JP WAITL
HELP1:	LD BC,MESS1	;PRINT OUT THE HELP MENU INSTRUCTIONS.
	LD A,2EH
	LD (COUNT),A
OUTA:	LD A,(BC)	;OUTPUT THE STRING.
	OUT 0F4H,A
	LD DE,OUT1
	LD (LOCA),DE
	JP WAITL
OUT1:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTA
	LD DE,HELP2	;CHECK FOR CONTINUE OR NEXT MESSAGE.
	LD (LOCA),DE
	JP POLL
HELP2:	IN A,0F4H
	CP 18H		;SEE IF EXITING THE HELP MESSAGE.
	JP NZ,MORE2
	JP CLEAR
MORE2:	LD A,0CH	;CLEAR SCREEN AND DISPLAY F2 MESSAGE.
	OUT 0F4H,A
	LD DE,F21A
	LD (LOCA),DE
	JP WAITL
F21A:	LD BC,HELPF2
	LD A,2CH
	LD (COUNT),A
OUTF2:	LD A,(BC)
	OUT 0F4H,A
	LD DE,F21B
	LD (LOCA),DE
	JP WAITL
F21B:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTF2
	LD DE,F21C
	LD (LOCA),DE
	JP POLL
F21C:	IN A,0F4H
	CP 18H
	JP NZ,F21D
	JP CLEAR
F21D:	LD A,0CH	;CLEAR SCREEN AND DISPLAY F3 HELP MESSAGE.
	OUT 0F4H,A	
	LD DE,MORE2A
	LD (LOCA),DE
	JP WAITL
MORE2A:	LD BC,MESS2	
	LD A,2FH
	LD (COUNT),A
OUTB:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT2
	LD (LOCA),DE
	JP WAITL
OUT2:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTB
	LD DE,MORE2B	;CHECK FOR CONTINUE OR NEXT MESSAGE.
	LD (LOCA),DE
	JP POLL
MORE2B:	IN A,0F4H
	CP 18H
	JP NZ,MORE3
	JP CLEAR
MORE3:	LD A,0CH	;CLEAR SCREEN AND DISPLAY F4 HELP MESSAGE.
	OUT 0F4H,A
	LD DE,MORE3A
	LD (LOCA),DE
	JP WAITL
MORE3A:	LD BC,MESS3
	LD A,2FH
	LD (COUNT),A
OUTC:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT3
	LD (LOCA),DE
	JP WAITL
OUT3:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTC
	LD DE,MORE3B
	LD (LOCA),DE
	JP POLL
MORE3B:	IN A,0F4H	;CHECK IF LEAVING THE HELP MENU.
	CP 18H
	JP NZ,MORE4
	JP CLEAR
MORE4:	LD A,0CH	;CLEAR SCREEN AND DISPLAY F5 MESSAGE.
	OUT 0F4H,A
	LD DE,MORE4A
	LD (LOCA),DE
	JP WAITL
MORE4A:	LD BC,MESS4
	LD A,2FH
	LD (COUNT),A
OUTD:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT4
	LD (LOCA),DE
	JP WAITL
OUT4:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTD
	LD DE,MORE4B
	LD (LOCA),DE
	JP POLL
MORE4B:	IN A,0F4H
	CP 18H
	JP NZ,MORE5A
	JP CLEAR
MORE5A:	LD A,0CH	;CLEAR SCREEN AND DISPLAY F6 MESSAGE.
	OUT 0F4H,A
	LD DE,MORE5B
	LD (LOCA),DE
	JP WAITL
MORE5B:	LD BC,MESS5
	LD A,29H
	LD (COUNT),A
OUTIT:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUTAT
	LD (LOCA),DE
	JP WAITL
OUTAT:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTIT
	LD DE,MORE5C
	LD (LOCA),DE
	JP POLL
MORE5C:	IN A,0F4H
	CP 18H
	JP NZ,F71
	JP CLEAR
F71:	LD A,0CH
	OUT 0F4H,A
	LD DE,F7A
	LD (LOCA),DE
	JP WAITL
F7A:	LD BC,HELPF7
	LD A,2FH
	LD (COUNT),A
OUTF7:	LD A,(BC)
	OUT 0F4H,A
	LD DE,F7B
	LD (LOCA),DE
	JP WAITL
F7B:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTF7
	LD DE,F7C
	LD (LOCA),DE
	JP POLL
F7C:	IN A,0F4H
	CP 18H
	JP NZ,F7D
	JP CLEAR
F7D:	LD A,0CH	;CLEAR SCREEN AN DISPLAY F8 MESSAGE.
	OUT 0F4H,A
	LD DE,F8A
	LD (LOCA),DE
	JP WAITL
F8A:	LD BC,HELPF8
	LD A,2FH
	LD (COUNT),A
OUTF8:	LD A,(BC)
	OUT 0F4H,A
	LD DE,F8B
	LD (LOCA),DE
	JP WAITL
F8B:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTF8
	LD DE,F8C
	LD (LOCA),DE
	JP POLL
F8C:	LD DE,CLEAR	;CLEAR SCREEN WHEN NEXT KEY IS PRESSED.
	LD (LOCA),DE
	JP WAITL


POLL:	IN A,0F5H	;CHECK IF THERE IS A CHARACTER IN THE INPUT BUFFER.
	BIT 0,A
	JP NZ,POLL1
	LD DE,POLL
	LD (JUMP1),DE	;SET THE LOOP BIT AND THE LOCATION FOR THE POLL LOOP.
	LD A,(VAL2)
	SET 0,A
	LD (VAL2),A
	LD D,B		;SAVE THE BC REGISTER PAIR.
	LD E,C
	LD (SVBC),DE
	RET
POLL1:	LD A,(VAL2)	;CLEAR THE POLL LOOP BIT AND JUMP TO PRESET LOCA.
	RES 0,A
	LD (VAL2),A
	LD HL,(LOCA)
	JP (HL)

MVIEW:	LD A,0CH
	OUT 0F4H,A
	LD DE,MVIE1
	LD (LOCA),DE
	JP WAITL
MVIE1:	LD BC,F2MES	;REQUEST WHAT MEMORY LOCATION TO VIEW.
	LD A,17H
	LD (COUNT),A
OUTE:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT5
	LD (LOCA),DE
	JP WAITL
OUT5:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTE
	LD A,1BH	;PLACE CURSOR ON BLANK LINES FOR ENTRY.
	OUT 0F4H,A
	LD DE,BAK1
	LD (LOCA),DE
	JP WAITL
BAK1:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK2
	LD (LOCA),DE
	JP WAITL
BAK2:	LD A,20H
	OUT 0F4H,A
	LD DE,MVIEWA
	LD (LOCA),DE
	JP WAITL
MVIEWA:	LD A,32H
	OUT 0F4H,A
	LD DE,NDEL5
	LD (LOCA),DE
	JP WAITL
NDEL5:  LD HL,MVIEWB	;WAIT FOR FIRST VALUE.
	LD (LOCA),HL
	JP POLL
MVIEWB:	IN A,0F4H
	CP 18H		;SEE IF CANCELLING COMMAND.
	JP Z,CLEAR
	OUT 0F4H,A
	CALL PROC	;CONVERT THE ASCII VALUE TO HEX AND 
	CALL ROTL	;ROTATE FOUR PLACES TO LEFT.
	LD D,A
NDEL8:	LD HL,MVIEWC	;SECOND VALUE.
	LD (LOCA),HL
	LD (VAL3),DE
	JP POLL
MVIEWC:	LD DE,(VAL3)
	IN A,0F4H
	CP 18H
	JP Z,CLEAR
	CP 7FH		;CHECK IF CHANGING FIRST CHARACTER.
	JP NZ,NDEL3
	OUT 0F4H,A
	LD HL,NDEL4
	LD (LOCA),HL
	LD (VAL3),DE
	JP WAITL
NDEL4:	LD DE,(VAL3)	;IF CHANGING FIRST VALUE THEN JUMP BACK.
	JP NDEL5
NDEL3:	LD (VAL4),DE
	OUT 0F4H,A
	CALL PROC
	XOR D
	LD D,A
	LD A,(VAL2)	;CHECK IF IN PORT VIEW FUNCTION.
	BIT 6,A
	JP NZ,PTVW2
	LD A,(VAL2)
	BIT 5,A		;CHECK IF IN PORT CHANGE FUNCTION.
	JP NZ,PTCHG1
	LD A,(TOGV)
	BIT 7,A
	JP NZ,TOGG4
NDELB:	LD HL,MVIEWD	;THIRD VALUE
	LD (LOCA),HL
	LD (VAL3),DE
	JP POLL
MVIEWD:	LD DE,(VAL3)
	IN A,0F4H
	CP 18H
	JP Z,CLEAR
	CP 7FH		;CHECK IF CHANGING SECOND VALUE.
	JP NZ,NDEL6
	OUT 0F4H,A
	LD HL,NDEL7
	LD (LOCA),HL
	JP WAITL
NDEL7:	LD DE,(VAL4)
	JP NDEL8
NDEL6:	LD (VAL5),DE
	OUT 0F4H,A
	CALL PROC
	CALL ROTL	;ROTATE FOUR PLACES TO THE LEFT.
	LD E,A
	LD HL,MVIEWE	;FOURTH VALUE.
	LD (LOCA),HL
	LD (VAL3),DE
	JP POLL
MVIEWE:	LD DE,(VAL3)
	IN A,0F4H
	CP 18H
	JP Z,CLEAR
	CP 7FH
	JP NZ,NDEL9
	OUT 0F4H,A
	LD HL,NDELA
	LD (LOCA),HL
	JP WAITL
NDELA:	LD DE,(VAL5)
	JP NDELB
NDEL9:	OUT 0F4H,A
	CALL PROC
	XOR E
	LD E,A
	LD (VAL6),DE
INCDCB:	LD A,(DE)
	LD (VAL1),A
	LD DE,MVIEWF
	LD (LOCA),DE
	JP WAITL
MVIEWF:	LD DE,(VAL3)
	LD A,(VAL2)	;CHECK IF IN CHANGE MEMORY FUNCTION.
	BIT 7,A
	JP NZ,CHGVA
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK3
	LD (LOCA),DE
	JP WAITL
BAK3:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK4
	LD (LOCA),DE
	JP WAITL
BAK4:	LD A,21H
	OUT 0F4H,A
	LD DE,MVIEWG
	LD (LOCA),DE
	JP WAITL
MVIEWG:	LD A,20H
	OUT 0F4H,A
	LD DE,MVIEWH
	LD (LOCA),DE
	JP WAITL
MVIEWH:	LD BC,MEMIS	;MESSAGE TELLING THE CONTENTS.
	LD A,0DH
	LD (COUNT),A
OUTF:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT6
	LD (LOCA),DE
	JP WAITL
OUT6:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTF
CHGVB:	LD A,(VAL1)	;OUTPUT THE CONTENTS OF REQUESTED LOCATION
	LD B,A		;IN ASCII.  NEXT SEVERAL STEPS CONVERT TO
	AND 80H		;ASCII AND OUTPUT THE VALUE.
	JP Z,ADDLO
	LD A,B
	AND 60H
	JP Z,ADDLO
	JP ADDH1
ADDLO:	LD A,B
	AND 0F0H
	CALL ROTR	;ROTATE FOUR PLACES TO THE RIGHT.
	ADD A,30H
	OUT 0F4H,A
	LD DE,MVIEWI
	LD (LOCA),DE
	JP WAITL
MVIEWI:	JP SECD
ADDH1:	LD A,B
	AND 0F0H
	CALL ROTR	;ROTATE FOUR PLACES TO THE RIGHT.
	ADD A,37H
	OUT 0F4H,A
	LD DE,MVIEWJ
	LD (LOCA),DE
	JP WAITL
MVIEWJ:	NOP
SECD:	LD A,B
	AND 0FH
	CALL ROTL	;ROTATE FOUR PLACES TO THE LEFT.
	LD B,A
	AND 80H
	JP Z,ADDL1
	LD A,B
	AND 60H
	JP Z,ADDL1
	JP ADDH2
ADDL1:	LD A,B
	CALL ROTR	;ROTATE FOUR PLACES TO THE RIGHT.
	ADD A,30H
	OUT 0F4H,A
	LD DE,MVIEWK
	LD (LOCA),DE
	JP WAITL
MVIEWK:	JP OUTEN
ADDH2:	LD A,B
	CALL ROTR	;ROTATE FOUR PLACES TO THE RIGHT.
	ADD A,37H
	OUT 0F4H,A
	LD DE,MVIEWL
	LD (LOCA),DE
	JP WAITL
MVIEWL:	NOP
OUTEN:	LD A,(VAL2)	
	BIT 7,A		;CHECK IF IN CHANGE MEMORY MODE.
	JP NZ,CHGVC
	LD A,(VAL2)
	BIT 6,A		;CHECK IF IN VIEW PORT MODE.
	JP NZ,PTVW3
	LD A,(VAL2)
	BIT 5,A		;CHECK IF IN PORT CHANGE MODE.
	JP NZ,CHGVC
	LD HL,MVIEWM	;CLEAR SCREEN WHEN NEXT KEY IS PRESSED
	LD (LOCA),HL
	LD A,48H
	OUT 0F4H,A
	JP POLL
MVIEWM:	IN A,0F4H
	CP 68H		;CHECK IF NEXT LOCATION REQUEST.
	JP Z,INC1
	CP 67H		;CHECK IF PREVIOUS LOCATION REQUEST.
	JP Z,DEC1
	JP CLEAR	;CLEAR IF NO FURTHER PROCESS AND RETURN.


	
PROC:	LD B,A
	AND 40H		;SEE IF VALUE IS NUMBER OR LETTER.
	JP Z,UNDER
	LD A,B
	SUB 37H		;CONVERT ASCII LETTER TO HEX.
	RET
UNDER:	LD A,B
	SUB 30H		;CONVERT ASCII NUMBER TO HEX.
	RET

CHVAL:	LD A,0CH	;CLEAR SCREEN BEFORE CHANGE MEMORY FUNCTION.
	OUT 0F4H,A
	LD DE,CHVAL0
	LD (LOCA),DE
	JP WAITL


CHVAL0:	LD BC,F4MES	;PRINT THE MEMORY LOCATION REQUEST MESSAGE.
	LD A,17H
	LD (COUNT),A
OUTG:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT10
	LD (LOCA),DE
	JP WAITL
OUT10: 	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTG
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK5
	LD (LOCA),DE
	JP WAITL
BAK5:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK6
	LD (LOCA),DE
	JP WAITL
BAK6:	LD A,20H
	OUT 0F4H,A
	LD DE,CHGV1
	LD (LOCA),DE
	JP WAITL
CHGV1:	LD A,32H
	OUT 0F4H,A
	LD DE,V1CHG
	LD (LOCA),DE
	JP WAITL
V1CHG:	LD A,(VAL2)	;SET THE CHANGE MEMORY FUNCTION BIT.
	SET 7,A
	LD (VAL2),A
	JP NDEL5	;JUMP TO READ IN THE MEMORY LOCATION TO CHANGE.

CHGVA:	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK7
	LD (LOCA),DE
	JP WAITL
BAK7:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK8
	LD (LOCA),DE
	JP WAITL
BAK8:	LD A,21H
	OUT 0F4H,A
	LD DE,CHGV2
	LD (LOCA),DE
	JP WAITL
CHGV2:	LD A,20H
	OUT 0F4H,A
	LD DE,CHGV3
	LD (LOCA),DE
	JP WAITL
CHGV3:	LD BC,CUMES	;PRINT THE CURRENTLY MESSAGE.
	LD A,0AH
	LD (COUNT),A
OUTH:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUT11
	LD (LOCA),DE
	JP WAITL
OUT11: 	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTH
	JP CHGVB	;JUMP TO OUTPUT THE CURRENT VALUE OF THE LOCATION.

CHGVC:	LD BC,NWMES	;OUTPUT THE MESSAGE REQUESTING THE NEW VALUE.
	LD A,0AH
	LD (COUNT),A
OUT12:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUTI
	LD (LOCA),DE
	JP WAITL
OUTI:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUT12
	LD A,1BH	;MOVE CURSOR TO INPUT THE NEW VALUE.
	OUT 0F4H,A
	LD DE,BAK9
	LD (LOCA),DE
	JP WAITL
BAK9:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK10
	LD (LOCA),DE
	JP WAITL
BAK10:	LD A,21H
	OUT 0F4H,A
	LD DE,CHGV6
	LD (LOCA),DE
	JP WAITL
CHGV6:	LD A,33H
	OUT 0F4H,A
	LD DE,CHGV7
	LD (LOCA),DE
	JP WAITL
CHGV7:	LD DE,CHGV8	;FIRST VALUE
	LD (LOCA),DE
	JP POLL
CHGV8:	IN A,0F4H
	CP 18H
	JP Z,CLEAR
	OUT 0F4H,A
	CALL PROC
	CALL ROTL
	LD D,A
	LD HL,NVALA	;SECOND VALUE
	LD (LOCA),HL
	LD (VAL3),DE
	JP POLL
NVALA:	LD DE,(VAL3)
	IN A,0F4H
	CP 18H
	JP Z,CLEAR
	CP 7FH		;CHECK IF CHANGING THE FIRST VALUE.
	JP NZ,NVAL1
	OUT 0F4H,A
	LD HL,NVALB
	LD (LOCA),HL
	LD (VAL3),DE
	JP WAITL
NVALB:	LD DE,(VAL3)
	JP CHGV7
NVAL1:	OUT 0F4H,A
	CALL PROC
	XOR D
	LD D,A
	LD A,(VAL2)	;SEE IF IN CHANGE PORT VALUE MODE.
	BIT 5,A
	JP NZ,PTCHG4
	LD HL,(VAL6)	;PLACE THE LOCATION TO CHANGE IN HL.
	LD (HL),D	;PLACE THE NEW VALUE IN THE MEMORY LOCATION.
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK11
	LD (LOCA),DE
	JP WAITL
BAK11:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK12
	LD (LOCA),DE
	JP WAITL
BAK12:	LD A,21H
	OUT 0F4H,A
	LD DE,NV1
	LD (LOCA),DE
	JP WAITL
NV1:	LD A,36H
	OUT 0F4H,A
	LD DE,NV2
	LD (LOCA),DE
	JP WAITL
NV2:	LD DE,NV3
	LD (LOCA),DE
	JP POLL
NV3:	IN A,0F4H	;CHECK IF NEXT LOCATION REQUEST.
	CP 68H
	JP Z,INC1
	CP 67H		;CHECK IF PREVIOUS LOCATION REQUEST.
	JP Z,DEC1
	JP CLEAR	;CLEAR FUNCTION AND RETURN.

	
PRTT5:  LD A,(VAL10)	;LOAD THE BITS TO CHECK WHICH KEY IS NEXT TO PROGRAM
	CP 00H		;CHECK IF THE ROUTINE IS JUST BEING ENTERED INTO.
	JP Z,PRWAIT	;ROUTINE TO DISPLAY THE WAIT MESSAGE
	CP 01H		;CHECK IF READY TO PROGRAM THE FIRST FUNCTION KEY
	JP Z,PRF1	;ROUTINE LOAD THE COUNT AND VALUES FOR THE F1 KEY
	CP 03H		;CHECK IF READY TO PROGRAM THE SECOND FUNCTION KEY
	JP Z,PRF2	;ROUTINE TO LOAD THE COUNT AND VALUES FOR THE F2 KEY
	CP 07H		;CHECK IF READY TO PROGRAM THE THIRD FUNCTION KEY
	JP Z,PRF3	;ROUTINE TO LOAD THE COUNT AND VALUES FOR THE F3 KEY
	CP 0FH		;CHECK IF READY FOR THE FOURTH FUNCTION KEY
	JP Z,PRF4	;ROUTINE FOR THE FOURTH KEY
	CP 1FH		;CHECK IF READY FOR THE FIFTH KEY
	JP Z,PRF5	;ROUTINE FOR THE FIFTH KEY
	CP 3FH		;CHECK IF READY FOR THE SIXTH KEY
	JP Z,PRF6	;ROUTINE FOR THE SIXTH KEY
	CP 7FH		;CHECK IF READY FOR THE SEVENTH KEY
	JP Z,PRF7	;ROUTINE FOR THE SEVENTH KEY
	CP 0FFH		;CHECK IF READY FOR THE EIGHTH KEY
	JP Z,PRF8	;ROUTINE FOR THE EIGHTH KEY
	CP 0F0H		;CHECK IF ALL KEYS HAVE BEEN PROGRAMED.
	JP Z,FINISH	;ROUTINE TO DISPLAY THE READY MESSAGE AND TONE.
	LD DE,CLEAR
	LD (LOCA),DE
	LD A,00H	;CLEAR THE FUNCTION KEY REGISTER.
	LD  (VAL10),A
	JP POLL		;CLEAR THE SCREEN WHEN THE NEXT BUTTON IS PUSHED.


PRBAK:	LD DE,(VAL7)
	LD A,(DE)
	OUT 0F4H,A	;OUTPUT THE STRING OF VALUES TO PROGRAM THE TT5.
	INC DE
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00
	JP Z,PRTT5
	LD (VAL7),DE
	CALL DELAY
	JP PRBAK

DELAY:	LD HL,01FFH
TT5WAIT:DEC HL
	EX (SP),IX
	EX (SP),IX
	LD A,H
	CP 00H
	JP NZ,TT5WAIT
	LD A,L
	CP 00H
	JP NZ,TT5WAIT
	RET



PRWAIT: LD A,05H
	LD (COUNT),A
	LD HL,PRDAT
	LD (VAL7),HL
	LD A,01H
	LD (VAL10),A
	JP PRBAK

PRF1:	LD A,08H
	LD (COUNT),A
	LD HL,F1DAT
	LD (VAL7),HL
	LD A,03H
	LD (VAL10),A
	JP PRBAK

PRF2:	LD A,08H
	LD (COUNT),A
	LD HL,F2DAT
	LD (VAL7),HL
	LD A,07H
	LD (VAL10),A
	JP PRBAK

PRF3:	LD A,08H
	LD (COUNT),A
	LD HL,F3DAT
	LD (VAL7),HL
	LD A,0FH
	LD (VAL10),A
	JP PRBAK

PRF4:	LD A,08H
	LD (COUNT),A
	LD HL,F4DAT
	LD (VAL7),HL
	LD A,1FH
	LD (VAL10),A
	JP PRBAK

PRF5:	LD A,08H
	LD (COUNT),A
	LD HL,F5DAT
	LD (VAL7),HL
	LD A,3FH
	LD (VAL10),A
	JP PRBAK

PRF6:	LD A,08H
	LD (COUNT),A
	LD HL,F6DAT
	LD (VAL7),HL
	LD A,7FH
	LD (VAL10),A
	JP PRBAK

PRF7:	LD A,08H
	LD (COUNT),A
	LD HL,F7DAT
	LD (VAL7),HL
	LD A,0FFH
	LD (VAL10),A
	JP PRBAK

PRF8:	LD A,08H
	LD (COUNT),A
	LD HL,F8DAT
	LD (VAL7),HL
	LD A,0F0H
	LD (VAL10),A
	JP PRBAK

FINISH:	LD A,07H
	LD (COUNT),A
	LD HL,DATPR
	LD (VAL7),HL
	LD A,55H
	LD (VAL10),A
	JP PRBAK


PTVIEW:	LD A,0CH 
	OUT 0F4H,A
	LD DE,VIEWPT
	LD (LOCA),DE
	JP WAITL

VIEWPT:	LD BC,PRTVW	;OUTPUT THE PORT VIEW MESSAGE.
	LD A,17H
	LD (COUNT),A
OUTPA:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUTPB
	LD (LOCA),DE
	JP WAITL
OUTPB:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTPA
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK13
	LD (LOCA),DE
	JP WAITL
BAK13:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK14
	LD (LOCA),DE
	JP WAITL
BAK14:	LD A,20H
	OUT 0F4H,A
	LD DE,OUTPC
	LD (LOCA),DE
	JP WAITL
OUTPC:	LD A,34H
	OUT 0F4H,A
	LD DE,OUTPD
	LD (LOCA),DE
	JP WAITL
OUTPD:	LD A,(VAL2)	;SET THE PORT VIEW BIT IN MEMORY.
	SET 6,A
	LD (VAL2),A
	JP NDEL5	;JUMP TO READ IN THE PORT LOCATION TO VIEW.

PTVW2:	LD A,(VAL2)
	SET 4,A
	LD (VAL2),A
	LD A,D
	LD (PORV),A	;STORE THE PORT LOCATION IN MEMORY.
	LD BC,PRVAL	;OUTPUT THE VALUE MESSAGE.
	LD A,08H
	LD (COUNT),A
PTVW2A:	LD A,(BC)
	OUT 0F4H,A
	LD DE,PTVW2B
	LD (LOCA),DE
	JP WAITL
PTVW2B:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,PTVW2A
	LD A,(PORV)
	LD C,A
	IN A,(C)	;READ IN THE VALUE OF THE PORT LOCATION.
	LD (VAL1),A
	LD (BITV),A
	JP CHGVB	;JUMP TO CHANGE THE VALUE TO ASCII AND OUTPUT.
			
PTVW3:	LD BC,ORMES	;DISPLAY THE OR MESSAGE BEFORE THE BINARY VALUE.
	LD A,07H
	LD (COUNT),A
PTVW3A:	LD A,(BC)
	OUT 0F4H,A
	LD DE,PTVW3B
	LD (LOCA),DE
	JP WAITL
PTVW3B:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,PTVW3A
TOGG6:	LD A,(BITV)
	BIT 7,A		;START CHECKING EACH BIT OF THE VALUE AND DISPLAYING
	JP Z,ZERO1	;THE ONE OR ZERO IN ASCII.
	CALL ONEOUT
	JP BIT7
ZERO1:	CALL ZEROUT
BIT7:	LD DE,BITA
	LD (LOCA),DE
	JP WAITL
BITA:	LD A,(BITV)
	BIT 6,A		;            "  "
	JP Z,ZERO2		
	CALL ONEOUT
	JP BIT6
ZERO2:	CALL ZEROUT
BIT6:	LD DE,BITB
	LD (LOCA),DE
	JP WAITL
BITB:	LD A,(BITV)
	BIT 5,A		;            "  "
	JP Z,ZERO3
	CALL ONEOUT
	JP BIT5
ZERO3:	CALL ZEROUT
BIT5:	LD DE,BITC
	LD (LOCA),DE
	JP WAITL
BITC:	LD A,(BITV)
	BIT 4,A		;            "  "
	JP Z,ZERO4
	CALL ONEOUT
	JP BIT4
ZERO4:	CALL ZEROUT
BIT4:	LD DE,BITD
	LD (LOCA),DE
	JP WAITL
BITD:	LD A,(BITV)
	BIT 3,A		;            "  "
	JP Z,ZERO5
	CALL ONEOUT
	JP BIT3
ZERO5:	CALL ZEROUT
BIT3:	LD DE,BITE
	LD (LOCA),DE
	JP WAITL
BITE:	LD A,(BITV)
	BIT 2,A		;            "  "
	JP Z,ZERO6
	CALL ONEOUT
	JP BIT2
ZERO6:	CALL ZEROUT
BIT2:	LD DE,BITF
	LD (LOCA),DE
	JP WAITL
BITF:	LD A,(BITV)
	BIT 1,A		;             "  "
	JP Z,ZERO7
	CALL ONEOUT
	JP BIT1
ZERO7:	CALL ZEROUT
BIT1:	LD DE,BITG
	LD (LOCA),DE
	JP WAITL
BITG:	LD A,(BITV)
	BIT 0,A		;CHECK THE FINAL BIT AND DISPLAY THE ZERO OR ONE
	JP Z,ZERO8	;IN ASCII.
	CALL ONEOUT
	JP BIT0
ZERO8:	CALL ZEROUT
BIT0:	LD DE,BITH
	LD (LOCA),DE
	JP WAITL
BITH:	LD A,(TOGV)
	BIT 7,A
	JP NZ,TOGG7
	LD DE,BITI
	LD (PTPL),DE	;MEMORY REGISTER FOR PORT MONITOR POLL LOCATION.
	JP POLLA	;GO TO PORT MONITOR POLL ROUTINE.
BITI:	IN A,0F4H
	CP 68H		;CHECK IF NEXT LOCATION REQUEST.
	JP Z,INCPT1
	CP 67H		;CHECK IF PREVIOUS LOCATION REQUEST.
	JP Z,DECPT1
	JP CLEAR	;CLEAR AND RETURN IF NO FURTHER PROCESS.


POLLA:	IN A,0F5H	;THIS IS THE POLL ROUTINE FOR THE PORT VIEW/MONITOR
	BIT 0,A		;ROUTINE.  IT WILL UPDATE THE SCREEN EVERY TIME THERE
	JP NZ,POLLB	;IS A CHANGE IN THE INPUT VALUE.
	LD DE,POLLA
	LD (JUMP3),DE
	LD A,(VAL2)	;SET THE POLLA BIT, SAVE THE REGISTERS, AND RETURN
	SET 4,A		;TO THE MAIN PROGRAM.
	LD (VAL2),A
	LD D,B
	LD E,C
	LD (SVBC),DE
	LD A,(PORV)	;CHECK TO SEE IF THE PORT VALUE IS DIFFERENT THAN
	LD C,A		;THE CURRENT VALUE IN MEMORY FROM THE LAST CHECK.
	IN A,(C)
	LD D,A
	LD A,(VAL1)
	CP D
	JP NZ,PTDIF1	;IF IT IS DIFFERENT THEN JUMP TO THE SCREEN UPDATE
	RET		;ROUTINE, OTHERWISE RETURN TO THE MAIN PROGRAM.

POLLB:	LD A,(VAL2)	;WHEN A NEW PORT LOCATION IS ENTERED OR IF A CLEAR
	RES 4,A		;SCREEN IS ENTERED CLEAR THE POLLA BIT AND PERFORM
	LD (VAL2),A	;THE DESIRED FUNCTION.
	LD HL,(PTPL)
	JP (HL)


PTDIF1:	LD A,D		;LOAD THE NEW VALUE IN THE DISPLAY REGISTER AND 
	LD (VAL1),A	;IN THE BINARY DISPLAY REGISTER.
	LD (BITV),A
	LD A,1BH	;PLACE THE CURSOR ON THE CONTENTS DISPLAY LOCATION.
	OUT 0F4H,A
	LD DE,BAK15
	LD (LOCA),DE
	JP WAITL
BAK15:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK16
	LD (LOCA),DE
	JP WAITL
BAK16:	LD A,21H
	OUT 0F4H,A
	LD DE,PTDIF2
	LD (LOCA),DE
	JP WAITL
PTDIF2:	LD A,26H
	OUT 0F4H,A
	LD DE,CHGVB
	LD (LOCA),DE
	JP WAITL

PCHG:	LD A,0CH
	OUT 0F4H,A
	LD DE,PTCHG
	LD (LOCA),DE
	JP WAITL

PTCHG:  LD BC,CHGPT	;OUTPUT THE MESSAGE ASKING FOR PORT NUMBER.
	LD A,18H
	LD (COUNT),A
OUTPC1:	LD A,(BC)
	OUT 0F4H,A
	LD DE,OUTPC2
	LD (LOCA),DE
	JP WAITL
OUTPC2:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTPC1
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK17
	LD (LOCA),DE
	JP WAITL
BAK17:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK18
	LD (LOCA),DE
	JP WAITL
BAK18:	LD A,20H
	OUT 0F4H,A
	LD DE,OUTPC3
	LD (LOCA),DE
	JP WAITL
OUTPC3:	LD A,34H	;SCREEN LOCATION FOR ENTERING DATA.
	OUT 0F4H,A
	LD DE,OUTPC4
	LD (LOCA),DE
	JP WAITL
OUTPC4:	LD A,(VAL2)	;SET THE PORT CHANGE BIT. 
	SET 5,A
	LD (VAL2),A
	JP NDEL5	;JUMP TO ENTER THE PORT ADDRESS.

PTCHG1:	LD A,D
	LD (PORV),A	;STORE THE CURRENT VALUE OF PORT LOCATION.
	LD A,1BH	;SET THE CURSOR TO DISPLAY LOCATION.
	OUT 0F4H,A
	LD DE,BAK19
	LD (LOCA),DE
	JP WAITL
BAK19:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK20
	LD (LOCA),DE
	JP WAITL
BAK20:	LD A,21H
	OUT 0F4H,A
	LD DE,PTCHG8
	LD (LOCA),DE
	JP WAITL
PTCHG8:	LD A,20H
	OUT 0F4H,A
	LD DE,PTCHG9
	LD (LOCA),DE
	JP WAITL
PTCHG9:	LD BC,CUMES	;OUT THE CURRENTLY: MESSAGE
	LD A,0AH
	LD (COUNT),A
PTCHG2: LD A,(BC)
	OUT 0F4H,A
	LD DE,PTCHG3
	LD (LOCA),DE
	JP WAITL
PTCHG3:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,PTCHG2
	LD A,(PORV)
	LD C,A
	IN A,(C)	;INPUT THE CURRENT PORT VALUE.
	LD (VAL1),A
	JP CHGVB	;JUMP TO CHANGE THE VALUE TO ASCII AND DISPLAY IT.
PTCHG4:	LD A,(PORV)
	LD C,A
	OUT (C),D	;CHANGE THE VALUE AT THE PORT LOCATION.
   	LD A,1BH	;MOVE THE CURSOR TO THE END OF THE LINE FOR
	OUT 0F4H,A	;EASIER READABILITY.
	LD DE,BAK21
	LD (LOCA),DE
	JP WAITL
BAK21:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK22
	LD (LOCA),DE
	JP WAITL
BAK22:	LD A,21H
	OUT 0F4H,A
	LD DE,PTCHG5
	LD (LOCA),DE
	JP WAITL
PTCHG5:	LD A,36H
	OUT 0F4H,A
	LD DE,PTCHG6
	LD (LOCA),DE
	JP WAITL
PTCHG6:	LD DE,BITI	;JUMP TO END OF PORT VIEW ROUTINE TO CHECK IF
	LD (LOCA),DE	;NEXT OR PREVIOUS LOCATION REQUEST, OR CLEAR
	JP POLL		;AND RETURN TO MAIN PROGRAM.


INC1:	LD HL,(VAL6)	;INCREMENT TO THE NEXT MEMORY LOCATION TO CHANGE
	INC HL		;OR VIEW.
	LD (VAL6),HL
	JP INCDC0

DEC1:	LD HL,(VAL6)	;DECREMENT TO THE PREVIOUS MEMORY LOCATION TO 
	DEC HL		;CHANGE OR VIEW.
	LD (VAL6),HL
	JP INCDC0

INCDC0:	LD A,1BH	;PLACE THE CURSOR AT THE MEMORY LOCATION DISPLAY
	OUT 0F4H,A	;LOCATION.
	LD DE,BAK23
	LD (LOCA),DE
	JP WAITL
BAK23:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK24
	LD (LOCA),DE
	JP WAITL
BAK24:	LD A,20H
	OUT 0F4H,A
	LD DE,INC2
	LD (LOCA),DE
	JP WAITL
INC2:	LD A,32H
	OUT 0F4H,A
	LD DE,DEC2
	LD (LOCA),DE
	JP WAITL
DEC2:	LD HL,(VAL6)	;LOAD THE NEW LOCATION TO VIEW OR CHANGE IN 
	LD A,H		;REGISTERS TO CONVERT TO ASCII AND DISPLAY.
	LD (VAL8),A
	LD A,L
	LD (VAL9),A
INCDC9:	LD A,(VAL2)	;THE NEXT SECTION IS PASSED THROUGH TWICE CONVERTING
	BIT 2,A		;THE MEMORY LOCATION TO VIEW OR CHANGE TO ASCII AND
	JP NZ,INCDC2	;DISPLAY.
	LD A,(VAL8)
	JP INCDC3
INCDC2:	LD A,(VAL9)
INCDC3:	LD B,A
	AND 80H
	JP Z,INDCL0
	LD A,B
	AND 60H
	JP Z,INDCL0
	JP INDCH1
INDCL0:	LD A,B
	AND 0F0H
	CALL ROTR
	ADD A,30H
	OUT 0F4H,A
	LD DE,INCDC4
	LD (LOCA),DE
	JP WAITL
INCDC4:	JP SCND
INDCH1:	LD A,B
	AND 0F0H
	CALL ROTR
	ADD A,37H
	OUT 0F4H,A
	LD DE,INCDC5
	LD (LOCA),DE
	JP WAITL
INCDC5:	NOP
SCND:	LD A,B
	AND 0FH
	CALL ROTL
	LD B,A
	AND 80H
	JP Z,INDCL1
	LD A,B
	AND 60H
	JP Z,INDCL1
	JP INDCH2
INDCL1:	LD A,B
	CALL ROTR
	ADD A,30H
	OUT 0F4H,A
	LD DE,INCDC6
	LD (LOCA),DE
	JP WAITL
INCDC6:	JP INCDC8
INDCH2:	LD A,B
	CALL ROTR
	ADD A,37H
	OUT 0F4H,A
	LD DE,INCDC7
	LD (LOCA),DE
	JP WAITL
INCDC7:	NOP
INCDC8:	LD A,(TOGV)
	BIT 7,A
	JP NZ,TOGLO3	;IF IN BIT TOGGLE MODE JUMP TO INPUT PORT VALUE.
	LD A,(VAL2)
	BIT 3,A
	JP NZ,PTID4
	LD (VAL2),A
	LD A,(VAL2)
	BIT 2,A
	JP NZ,INCDCA
	SET 2,A
	LD (VAL2),A
	JP INCDC9
INCDCA:	LD A,(VAL2)
	RES 2,A
	LD (VAL2),A
	LD DE,(VAL6)
	JP INCDCB

INCPT1:	LD A,(PORV)	;INCREMENT TO THE NEXT PORT TO VIEW OR CHANGE.
	INC A
	LD (PORV),A
	LD A,(TOGV)
	BIT 7,A
	JP Z,PTID
	JP TOGLO0  	;IF IN PORT BIT TOGGLE MODE JUMP TO PLACE CURSOR.

DECPT1:	LD A,(PORV)	;DECREMENT TO THE PREVIOUS PORT TO VIEW OR CHANGE.
	DEC A
	LD (PORV),A
	LD A,(TOGV)
	BIT 7,A
	JP Z,PTID
	JP TOGLO0

PTID:	LD A,1BH	;PLACE THE CURSOR IN THE DISPLAY AREA.
	OUT 0F4H,A
	LD DE,BAK25
	LD (LOCA),DE
	JP WAITL
BAK25:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK26
	LD (LOCA),DE
	JP WAITL
BAK26:	LD A,20H
	OUT 0F4H,A
	LD DE,PTID2
	LD (LOCA),DE
	JP WAITL
PTID2:	LD A,34H
	OUT 0F4H,A
	LD DE,PTID3
	LD (LOCA),DE
	JP WAITL
PTID3:	LD A,(VAL2)	;SET A BIT THAT SHOWS THAT A PORT IS BEING
	SET 3,A		;INCREMENTED OR DECREMENTED THEN GO TO 
	LD (VAL2),A	;ROUTINE THAT WILL CONVERT THE PORT TO ASCII
	LD A,(PORV)	;AND DISPLAY IT.
	JP INCDC3
PTID4:	LD A,(PORV)
	LD D,A
	LD A,(VAL2)	;CHECK IF PORT CHANGE MODE.
	BIT 5,A
	JP NZ,PTCHG1
	JP PTVW2	;IF NOT CHANGING A PORT JUMP TO VIEW ROUTINE.


TOGGLE:	LD A,0CH
	OUT 0F4H,A
	LD DE,TOGG0
	LD (LOCA),DE
	JP WAITL
TOGG0:	LD BC,TOGMES
	LD A,24H
	LD (COUNT),A
OUTTOG:	LD A,(BC)
	OUT 0F4H,A
	LD DE,TOGG1
	LD (LOCA),DE
	JP WAITL
TOGG1:	INC BC
	LD A,(COUNT)
	DEC A
	LD (COUNT),A
	CP 00H
	JP NZ,OUTTOG
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK27
	LD (LOCA),DE
	JP WAITL
BAK27:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK28
	LD (LOCA),DE
	JP WAITL
BAK28:	LD A,21H
	OUT 0F4H,A
	LD DE,TOGG2
	LD (LOCA),DE
	JP WAITL
TOGG2:	LD A,29H
	OUT 0F4H,A
	LD DE,TOGG3
	LD (LOCA),DE
	JP WAITL
TOGG3:	LD A,(TOGV)
	SET 7,A
	LD (TOGV),A
	JP NDEL5

TOGG4:	LD A,D
	LD (PORV),A
	LD C,A
	IN A,(C)
	LD (BITV),A
	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK29
	LD (LOCA),DE
	JP WAITL
BAK29:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK30
	LD (LOCA),DE
	JP WAITL
BAK30:	LD A,21H
	OUT 0F4H,A
	LD DE,TOGG5
	LD (LOCA),DE
	JP WAITL
TOGG5:	LD A,2FH
	OUT 0F4H,A
	LD DE,TOGG6
	LD (LOCA),DE
	JP WAITL

TOGG7:	LD DE,TOGG8
	LD (LOCA),DE
	JP POLL

TOGG8:	IN A,0F4H
	CP 68H
	JP Z,INCPT1
	CP 67H
	JP Z,DECPT1
	CP 37H
	JP Z,TOGSEV
	CP 36H
	JP Z,TOGSIX
	CP 35H
	JP Z,TOGFIV
	CP 34H
	JP Z,TOGFOR
	CP 33H
	JP Z,TOGTHR
	CP 32H
	JP Z,TOGTWO
	CP 31H
	JP Z,TOGONE
	CP 30H
	JP Z,TOGZRO
	JP CLEAR

TOGSEV:	LD A,(BITV)
	BIT 7,A
	JP NZ,SEVRES
	SET 7,A
	LD (BITV),A
	JP TOGOUT
SEVRES:	RES 7,A
	LD (BITV),A
	JP TOGOUT
TOGSIX:	LD A,(BITV)
	BIT 6,A
	JP NZ,SIXRES
	SET 6,A
	LD (BITV),A
	JP TOGOUT
SIXRES:	RES 6,A
	LD (BITV),A
	JP TOGOUT
TOGFIV:	LD A,(BITV)
	BIT 5,A
	JP NZ,FIVRES
	SET 5,A
	LD (BITV),A
	JP TOGOUT
FIVRES:	RES 5,A
	LD (BITV),A
	JP TOGOUT
TOGFOR:	LD A,(BITV)
	BIT 4,A
	JP NZ,FORRES
	SET 4,A
	LD (BITV),A
	JP TOGOUT
FORRES:	RES 4,A
	LD (BITV),A
	JP TOGOUT
TOGTHR:	LD A,(BITV)
	BIT 3,A
	JP NZ,THRRES
	SET 3,A
	LD (BITV),A
	JP TOGOUT
THRRES:	RES 3,A
	LD (BITV),A
	JP TOGOUT
TOGTWO:	LD A,(BITV)
	BIT 2,A
	JP NZ,TWORES
	SET 2,A
	LD (BITV),A
	JP TOGOUT
TWORES:	RES 2,A
	LD (BITV),A
	JP TOGOUT
TOGONE:	LD A,(BITV)
	BIT 1,A
	JP NZ,ONERES
	SET 1,A
	LD (BITV),A
	JP TOGOUT
ONERES:	RES 1,A
	LD (BITV),A
	JP TOGOUT
TOGZRO:	LD A,(BITV)
	BIT 0,A
	JP NZ,ZRORES
	SET 0,A
	LD (BITV),A
	JP TOGOUT
ZRORES:	RES 0,A
	LD (BITV),A
	JP TOGOUT

TOGOUT:	LD A,(BITV)
	LD D,A
	LD A,(PORV)
	LD C,A
	OUT (C),D
	LD DE,TOGG9
	LD (LOCA),DE
	JP WAITL


TOGG9:	LD A,(PORV)
	LD D,A
	JP TOGG4

TOGLO0:	LD A,1BH
	OUT 0F4H,A
	LD DE,BAK31
	LD (LOCA),DE
	JP WAITL
BAK31:	LD A,47H
	OUT 0F4H,A
	LD DE,BAK32
	LD (LOCA),DE
	JP WAITL
BAK32:	LD A,21H
	OUT 0F4H,A
	LD DE,TOGLO1
	LD (LOCA),DE
	JP WAITL
TOGLO1:	LD A,29H
	OUT 0F4H,A
	LD DE,TOGLO2
	LD (LOCA),DE
	JP WAITL
TOGLO2:	LD A,(PORV)
	JP INCDC3

TOGLO3:	LD A,(PORV)
	LD D,A
	JP TOGG4 

	
PRDAT:	DB	0CH,57H,41H,49H,54H	;VALUES FOR PROGRAMING THE TT5.
F1DAT:	DB	1BH,57H,31H,36H,31H,30H,30H,2AH
F2DAT:	DB	1BH,57H,32H,36H,32H,30H,30H,2AH
F3DAT:	DB	1BH,57H,33H,36H,33H,30H,30H,2AH
F4DAT:  DB	1BH,57H,34H,36H,34H,30H,30H,2AH
F5DAT:	DB	1BH,57H,35H,36H,35H,30H,30H,2AH
F6DAT:	DB	1BH,57H,36H,36H,36H,30H,30H,2AH
F7DAT:	DB	1BH,57H,37H,36H,37H,30H,30H,2AH
F8DAT:	DB	1BH,57H,38H,36H,38H,30H,30H,2AH
DATPR:	DB	20H,52H,45H,41H,44H,59H,07H


MESS1:	DEFM	'HELP MENU- CLEAR TO EXIT   ANY KEY TO CONTINUE'


HELPF2:	DEFM	'   F2= TOGGLE BITS OF      VALUE IN PORT __H'


MESS2:	DEFM	'  F3= VIEW CONTENTS OF   MEMORY LOCATION ____H.'


MESS4:	DEFM	'F5= VIEW CONTENTS OF I/OLOCATION __H IN BINARY.'


MESS3:	DEFM	'  F4= CHANGE VALUE IN    MEMORY LOCATION ____H.'


MESS5:	DEFM	'F6= CHANGE VALUE OF I/O    LOCATION __H. '


HELPF7:	DEFM	'F7=DECREMENT TO PREVIOUSMEMORY OR PORT LOCATION'


HELPF8:	DEFM	' F8= INCREMENT TO NEXT  MEMORY OR PORT LOCATION'


F2MES:	DEFM	'ADDRESS TO VIEW   ____H'


MEMIS:	DEFM	'CONTENTS ARE:'


F4MES:	DEFM	'ADDRESS TO CHANGE ____H'


CUMES:	DEFM	'CURRENTLY:'


NWMES:	DEFM	'H  NEW:__H'


PRTVW:	DEFM	'WHICH PORT TO VIEW: __H'


PRVAL:	DEFM	'  VALUE:'


ORMES:	DEFM	'H  OR  '


CHGPT:	DEFM	'    PORT TO CHANGE  __H '


TOGMES:	DEFM	'WHICH PORT TO  76543210  TOGGLE: __H'


ROTR:	RRCA
	RRCA
	RRCA
	RRCA
	RET

ROTL:	RLCA
	RLCA
	RLCA
	RLCA
	RET

ZEROUT:	LD A,30H	;DISPLAY A ZERO IN ASCII.
	OUT 0F4H,A
	RET

ONEOUT:	LD A,31H	;DISPLAY A ONE IN ASCII.
	OUT 0F4H,A
	RET


	END
