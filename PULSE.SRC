
		;      >>>>>>>>>>>    PULSE MODULE	<<<<<<<<<<<

	NAME	PULSE
	ORG	0500H


	EXTRN	CALREG,REG1,REG2,TIMEREG,CURCNT,MEMCNT,ESICNT,RUNREG,ESIRLY
	EXTRN	SHIFT1,SHIFT2,STOPCNT,STPREG,OUTCNT,BOWLCNT,JOGCNT,PARTCNT
	EXTRN	KICKCNT,TESTCNT,PORT06,ESIDWN,BOWLDWN,OUTDWN,PORT04
	EXTRN	SLOWCNT,SLOWDWN,OVENTME,OVENDWN,ERRREG



	GLOBAL	PULSE

             	;********************************************************
		;*							*
		;*		THIS PULSE MODULE IS CALLED BY  	*
		;*    	THE PULSE INTERUPT TO CHECK THE VALIDITY	*
		;*	OF THE PULSE AND THE DIRECTION OF THE		*
		;*	OF THE ENCODER.  IF THE ENCODER IS   		*
		;*	MOVING IN THE FORWARD DIRECTION A COUNT		*
		;*	WILL BE INCREMENTED.  THIS RUNNING COUNT 	*
		;*	WILL BE COMPARED WITH SET VALUES TO KNOW	*
		;*	WHEN TO START A TEST CYCLE AND WHEN TO		*
		;*	EJECT A BAD PART.  WHEN THE PULSE COUNT		*
		;*	REACHES 360 DEGREES (168H) THE COUNT WILL	*
		;*	BE RESET TO 0.  WHEN THE ENCODER IS TURNING	*
		;*	IN REVERSE THE LAST FORWARD COUNT IS SAVED	*
		;*	AND THE CURRENT COUNT IS DECREMENTED.  NO	*
		;*	OPERATIONS ARE PERFORMED IN THE REVERSE		*
		;*	DIRECTION.  WHEN THE DIRECTION BEGINS MOVING	*
		;*	FORWARD AFTER HAVING BEEN TRAVELING IN THE 	*
		;*	REVERSE DIRECTION THE COUNT IS INCREMENTED	*
		;*	BUT NO OPERATIONS ARE PERFORMED UNTIL THE 	*
		;*	CURRENT COUNT HAS REACHED THE VALUE WHICH	*
		;*	WAS SAVED WHEN THE ENCODER BEGAN TO TRAVEL	*
		;*	IN THE REVERSE DIRECTION.  THIS PROHIBITS 	*
		;*	ANY OPERATION FROM BEING REPEATED TWICE IN	*
		;*	THE SAME 360 DEGREE CYCLE.			*
		;********************************************************



PULSE:	PUSH	AF		;SAVE THE REGISTERS FROM THE MAIN PROGRAM
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	A,(CALREG)
	BIT	2,A		;CHECK TO SEE IF IN CALIBRATION PROCESS
	JP	Z,APULSE	;IF SO LEAVE THE PULSE ROUTINE
	LD	A,(REG1)	;CHECK IF EMERGENCY STOP OCCURED
	BIT	0,A		
	JP	Z,NOPUL		
APULSE:	IN 	A,05H
	BIT	3,A		;CHECK DIRECTION OF ENCODER.
	JP	Z,BACKUP	;IF IN REVERSE DIRECTION JUMP **CHK BIT**
	LD	A,(REG1)
	BIT	3,A		;CHECK IF REVERSE MEMORY BIT IS SET.
	JP	Z,CNTINC
	LD	HL,(CURCNT)	;LOAD THE CURRENT PULSE COUNT TO COMPARE
	LD	DE,(MEMCNT)	;LOAD THE LAST FORWARD COUNT VALUE
	SBC	HL,DE		;CURRENT COUNT - LAST FORWARD COUNT = ?
	JP	M,RETINC	;IF ? IS NEGATIVE JUMP TO INC AND RETI.
	JP	Z,INCRET	;IF ? IS ZERO JUMP TO INC AND RETI.
	JP	RETINC		;THIS LINE AND ONE ABOVE WERE ADDED&&&&&&&&&&
INCRET:	LD	A,(REG1)	;RESET THE REVERSE MEMORY BIT IF THE 
	RES	3,A		;CURRENT COUNT IS NOW LARGER THAN THE 
	LD	(REG1),A	;LAST FORWARD COUNT BEFORE REVERSING.

			;************************************************
			;*	THIS ROUTINE IS JUMPED TO, TO INCREMENT	*
			;*  THE POSITION COUNT WHEN THE MACHINE IS IN 	*
			;*  THE FORWARD MOVING DIRECTION AND THE REVERSE*
			;*  MEMORY FLAG IS NO LONGER SET.  SEVERAL 	*
			;*  ROUTINES ARE CALLED TO COMPARE THE CURRENT	*
			;*  POSITION COUNT WITH THE COUNTS THAT INVOLVE	*
			;*  THE PROCESSES TO BE PERFORMED.  WHEN A COUNT*
			;*  COMPARES EQUAL TO THE CURRENT COUNT AND THE	*
			;*  CONDITION FLAGS ARE MET THE CORRESPONDING   *
			;*  ROUTINE WILL BE PERFORMED.  THE PROGRAM WILL*
			;*  THEN RESTORE THE REGISTERS AND RETURN TO THE*
			;*  MAIN PROGRAM.				*
			;************************************************
CNTINC:	LD	HL,(CURCNT)	;INCREMENT THE CURRENT COUNT
	INC	HL
	LD	(CURCNT),HL
	JP	TESTBT

TESTBT:	LD	A,(REG1)
	BIT	0,A		;DID E. STOP OCCUR
	JP	Z,BTTEST
	CALL	KICKIT
	JP	NOPUL
BTTEST:	CALL	STOPIT
	CALL	TESTIT
	CALL	PARTIT
	CALL	KICKIT
	CALL	JOGIT
	CALL	ZEROIT
	CALL	OVENP
NOPUL:	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RETI

    			;************************************************
    			;*	THIS ROUTINE WILL BE JUMPED TO IF THE 	*
    			;*  MACHINE IS RUNNING IN THE REVERSE DIRECTION.*
    			;*  IF THE REVERSE MEMORY BIT (INDICATES THE 	*
    			;*  MACHINE IS RUNNING IN REVERSE SO NO 	*
    			;*  OPERATIONS WILL OCCUR) IS SET, THE CURRENT	*
        		;*  COUNT IS DECREMENTED AND THE PROGRAM JUMPS	*
    			;*  TO THE END TO RESTORE THE REGISTERS AND RETI*
    			;*	IF THE REVERSE FLAG WAS NOT SET,  IT 	*
    			;*  WILL BE SET, THE CURRENT COUNT STORED, AND	*
    			;*  THEN THE COUNT WILL BE DECREMENTED AND THE	*
    			;*  PROGRAM WILL JUMP TO THE END OF THE ROUTINE	*
    			;*  TO RESTORE THE REGISTERS AND RETI.		*
       			;************************************************
        
BACKUP:	LD	A,(REG1)	;CHECK THE REVERSE MEMORY BIT.
	BIT	3,A
	JP	Z,NOBACK	;IF NOT SET, JUMP TO SET IT AND LOAD REGISTERS
	LD	HL,(CURCNT)	;REVERSE BIT SET SO DECREMENT COUNT AND
	DEC	HL		;JUMP TO END OF MODULE
	LD	(CURCNT),HL
	JP	NOPUL

NOBACK:	LD	A,(REG1)	;MACHINE IS NOW REVERSING SO SET BIT.
	SET	3,A
	LD	(REG1),A
	LD	HL,(CURCNT)	;STORE THE CURRENT COUNT IN THE REVERSE
	LD	(MEMCNT),HL	;COUNT MEMORY LOCATION FOR FUTURE COMPARISONS.
	LD	HL,(CURCNT)	;DECREMENT THE CURRENT COUNT
	DEC	HL
	LD	(CURCNT),HL
	JP	NOPUL

    			;************************************************
    			;*	THIS ROUTINE WILL BE JUMPED TO IF THE 	*
    			;*  MACHINE IS RUNNING IN THE FORWARD DIRECTION	*
       			;*  BUT THE CURRENT COUNT IS STILL LESS THAT THE*
    			;*  MEMORY COUNT THAT WAS SET WHEN THE MACHINE	*
    			;*  FIRST STARTED TO GO IN THE REVERSE DIRECTION*
    			;*	THE COUNT WILL BE INCREMENTED BUT NO	*
    			;*  COMPARISONS WILL BE MADE.  THIS WILL 	*
    			;*  PROHIBIT ANY REPEAT STEPS DURING ONE MACHINE*
    			;*  CYCLE.  THE PROGRAM WILL THEN JUMP TO 	*
       			;*  RESTORE THE REGISTERS AND RETURN.		*
    			;************************************************
    
RETINC:	LD	HL,(CURCNT)	;MOVING FORWARD BUT NOT PAST THE LAST
	INC	HL		;FORWARD COUNT SO INCREMENT THE CURRENT
	LD	(CURCNT),HL	;COUNT AND JUMP TO END OF THE MODULE.
	JP	NOPUL
    		
    			;************************************************
    			;*	THIS ROUTINE IS CALLED TO CHECK IF IT 	*
    			;*  IS TIME FOR THE MACHINE TO START THE TEST 	*
    			;*  PROCEDURE.  				*
    			;*   	IF THE MACHINE IS ALREADY TAKING A TEST	*
    			;*  THE ROUTINE WILL RETURN FROM THE CALL.	*
    			;*	THIS ROUTINE WILL COMPARE A VALUE THAT	*
    			;*  WAS ENTERED BY THE TT5 TO THE CURRENT COUNT	*
    			;*  AND IF THE TWO VALUES ARE NOT EQUAL THE 	*
    			;*  ROUTINE WILL RETURN FROM THE CALL.		*
    			;*	IF THE NUMBERS DO COMPARE THE TESTON	*
    			;*  WILL BE CALLED.  WHEN IT RETURNS THE 	*
    			;*  PROGRAM WILL RETURN FROM THE CALL BACK TO 	*
    			;*  THE PULSE ROUTINE.				*
    			;************************************************
TESTIT:	LD	A,(RUNREG)	;CHECK TO SEE IF THE MACHINE IS ALREADY
	BIT	2,A		;TESTING A PART.  
	RET	NZ		;IF IT IS THEN RETURN.
	LD	HL,(CURCNT)
	LD	DE,(TESTCNT)	
	LD	A,D
	CP 	H		;CHECK IF IT IS TIME TO START THE TEST 
	RET	NZ		;SEQUENCE BY COMPARING THE CURRENT COUNT
	LD	A,E		;TO THE TEST COUNT LOCATION VALUE.
	CP	L		;IF IT IS NOT THEN RETURN, IF IT IS, START
	RET	NZ		;THE TEST PROCEDURE.
	CALL	TESTON
	RET

    			;************************************************
    			;*	THIS ROUTINE WILL SET THE COMM2 SWITCH	*
    			;*  LEAD IN THE ESI BRIDGE AND RESET THE 	*
    			;*  NORMALLY OPEN LEAD IN THE ESI BRIDGE.  THIS	*
    			;*  WILL START THE TEST CYCLE.  THE ROUTINE WILL*
    			;*  ALSO LOAD THE 10mS COUNT VALUE FOR THE TIMER*
    			;*  ROUTINE AND THE TEST REQUEST FLAG.		*
    			;************************************************
TESTON:	LD	A,(PORT04)	;SET THE COMM2 CONTACT OF THE ESI BRIDGE.
	SET	6,A
	RES	7,A		;RESET THE N.O. CONTACT OF THE ESI BRIDGE.
	OUT 	04H,A
	LD	(PORT04),A
	LD	A,(RUNREG)	;TIME TO TEST.  SET THE TEST REQUEST BIT.
	SET	2,A
	LD	(RUNREG),A
	LD	A,(ESICNT)	;LOAD THE 10mS TIME CONSTANT VALUE.
	LD	(ESIDWN),A
	RET

    			;************************************************
    			;*	THIS ROUTINE IS CALLED TO CHECK IF IT	*
    			;* IS TIME FOR THE BAD PART KICKOUT SEQUENCE TO	*
    			;*  BEGIN.					*
    			;*	THE ROUTINE FIRST CHECKS IF THE TEST	*
       			;*  HAS BEEN DONE TO DETERMINE IF A PART IS 	*
			;*  PRESENT IN THE CHAIN OR NOT.  THE ROUTINE	*
    			;*  WILL THEN CHECK IF THE TEST IS ALREADY 	*
    			;*  BEING DONE.  THIS MAKES SURE THE TEST WILL	*
    			;*  NOT BE DONE TWICE DURING THE SAME CYCLE.	*
    			;*  THE COUNT IS THEN COMPARED TO SEE IF THE 	*
    			;*  MACHINE IS IN THE CORRECT LOCATION TO KICK	*
    			;*  THE PART OUT.  THE ROUTINE WILL THEN CHECK	*
    			;*  IF THE PART IS GOOD OR BAD.  IF THE PART	*
    			;*  WAS GOOD THE KICKOUT PROCEDURE WILL NOT BE	*
    			;*  PERFORMED.  IF ALL OF THE CONDITION TESTS	*
    			;*  PASS A ROUTINE WILL BE CALLED TO START THE	*
    			;*  THE PROCEDURE.  WHEN THE ROUTINE RETURNS	*
    			;*  THE PART THERE FLAG IS RESET.		*
    			;*	THE PROGRAM WILL THEN RETURN TO PULSE.	*
    			;************************************************
   
KICKIT:	LD	HL,(CURCNT)
	LD	DE,(KICKCNT)	;CHECK TO SEE IF IT IS TIME TO EJECT THE 
	LD	A,D		;PART.
	CP	H
	RET	NZ		;RETURN IF NOT TIME TO EJECT
	LD	A,E
	CP	L
	RET	NZ		;RETURN IF NOT TIME TO EJECT
	LD	A,(SHIFT1)
	BIT	6,A		;SEE IF THE PART IS BAD 
	JP	Z,NOKICK
	CALL	KICKON
NOKICK:	LD	A,(RUNREG)
	RES	5,A		;PART HERE TESTED FLAG
	LD	(RUNREG),A
	RET

			;************************************************
    			;*	THIS ROUTINE WILL TURN ON THE KICKOUT	*
    			;*  AIR SOLENOID, SET THE KICKOUT REQUEST FLAG	*
    			;*  FOR THE TIMERS ROUTINE, AND LOAD THE 10mS	*
    			;*  COUNT VALUE FOR THE TIMERS ROUTINE.		*
    			;************************************************
KICKON:	LD	A,(TIMEREG)	;TIME TO EJECT.  SET THE KICKOUT REQUEST 
	SET	0,A		;FLAG.
	LD	(TIMEREG),A
	LD	A,(OUTCNT)	;LOAD THE 10mS TIME CONSTANT VALUE.
	LD	(OUTDWN),A
	LD	A,(PORT06)
	SET	3,A		;TURN ON THE EJECT SOLENOID.
	OUT	06H,A
	LD	(PORT06),A
	RET

			;************************************************
			;*	THIS ROUTINE WILL CHECK IF THE CURRENT	*
			;*  IS AT 360 DEGREES, AND IF SO RESET THE COUNT*
			;*  TO ZERO.					*
			;************************************************
ZEROIT:	LD	HL,(CURCNT)
	LD	A,H
	CP	01H		;CHECK IF THE COUNT IS AT 360 DEGREES.
	RET	NZ
	LD	A,L		
	CP	68H
	RET	NZ
	LD	H,00H		;IF IT IS RESET THE COUNT TO ZER0.
	LD	L,00H
	LD	(CURCNT),HL
	RET

			;************************************************
			;*	THIS ROUTINE WILL STOP THE MACHINE	*
			;*  IF THERE HAS BEEN A REQUEST TO DO SO AND IF	*
			;*  THE MACHINE IS IN THE CORRECT LOCATION.	*
			;*	DEPENDING ON WHICH MODE THE MACHINE IS	*
			;*  IN (JOG, RUN, CALIBRATE) DIFFERENT FLAGS 	*
			;*  WILL BE CLEARED OR SET.			*
			;*	THE LOCATION FOR THE STOP ROUTINE IS	*
			;*  DETERMINED BY WHAT WORKS OUT BEST FOR THE	*
			;*  OPERATOR.  THE VALUE IS ENTERED WITH THE 	*
			;*  THE TT5 TERMINAL.				*
			;************************************************
	
STOPIT:	LD	A,(STPREG)	;CHECK IF THE STOP SET BIT IS SET
	BIT	7,A
	RET	Z		;IF STPSET BIT IS CLEAR RETURN TO PULSE.
	LD	HL,(CURCNT)
	LD	DE,(STOPCNT)
	LD	A,D
	CP	H
	RET	NZ		;IF NOT AT THE STOP LOCATION RETURN TO PULSE
	LD	A,E
	CP	L
	RET	NZ		;IF NOT AT THE STOP LOCATION RETURN TO PULSE
	LD	A,(CALREG)
	BIT	4,A		;IS THE CALIBRATION STOP REQUEST FLAG SET
	JP	NZ,STPCAL	;IF SO, JUMP TO CALIBRATION MODE STOP 
	LD	A,(REG1)
	BIT	2,A		;ARE WE IN THE JOG MODE
	JP	NZ,STPJOG	;IF SO, JUMP TO JOG MODE STOP SEQUENCE
	LD	A,(PORT06)
	RES	5,A		;RESET THE OVEN FLAG
				;RES	4,A	RESET THE SYNTRON BOWL
	OUT	06H,A
	LD	(PORT06),A
	JP	STPRUN

STPJOG:	LD	A,(REG1)
	RES	2,A		;RESET THE JOGGING MODE FLAG
	LD	(REG1),A
STPRUN:	LD	A,(REG1)
	RES	1,A		;RESET THE RUNNING FLAG
	LD	(REG1),A
	LD	A,(PORT06)
	RES	6,A		;RESET THE MOTOR FLAG
				;RES	2,A	RESET THE RACK VIBRATOR
	OUT	06H,A
	LD	(PORT06),A
	LD	A,(STPREG)
	XOR	A		;RESET THE STOP REQUEST FLAG&& RES 7,A &&&&&&
	LD	(STPREG),A
	LD	A,(TIMEREG)
	BIT	6,A		;ARE WE RESETTING SET UP MODE WHILE RUNNING
	RET	Z		;IF NOT RETURN
	RES	7,A		;RESET THE SETUP MODE FLAG
	RES	6,A		;RESET THE CLEARING FLAG
	LD	(TIMEREG),A
	RET
				;*********************************************
				;THIS IS THE STOP ROUTINE FOR THE CALIBRATE
				;                   PROCESS
				;*********************************************

STPCAL:	LD	A,(PORT06)
	RES	6,A		;TURN OFF THE MOTOR
	OUT	06H,A
	LD	(PORT06),A
	LD	A,(REG2)	;IN	A,01H
	BIT	4,A		;IF THE LOAD DISABLE FLAG IS ACTIVE  BIT 2,A
	JP	NZ,CALSTP	;DO NOT RESET THE LOAD DISABLER
	LD	A,(PORT06)
	RES	1,A		;RESET THE LOAD DISABLER
	OUT	06H,A
	LD	(PORT06),A
CALSTP:	LD	A,(CALREG)
	SET	7,A		;SET THE CALIBRATION MEMORY FLAG
	LD	(CALREG),A
	LD	A,(STPREG)
	RES	7,A		;RESET THE STOP REQUEST FLAG
	LD	(STPREG),A
	LD	A,(CALREG)
	RES	4,A		;RESET THE CALIBRATION STOP REQUEST
	RES	0,A		;RESET THE CALIBRATION PROCESS FLAG
	LD	(CALREG),A
	LD	A,(REG1)
	BIT	0,A		;CHECK THE MCR DISABLED FLAG
	RET	Z
	LD	A,(REG1)
	RES	0,A		;RESET THE MCR DISABLE OCCURED FLAG.
	LD	(REG1),A
	RET

			;************************************************
			;*	THIS ROUTINE IS USED WHEN THE MACHINE 	*
			;*  IS IN THE JOG MODE TO SET THE STOP REQUEST.	*
			;*  	SINCE THE MACHINE IS IN THE STOP 	*
			;*  LOCATION WHEN THE JOG MODE IS REQUESTED, 	*
			;*  THIS SEPERATE LOCATION ASSURES THE MACHINE	*
			;*  WILL NOT ALREADY SEE THAT IT IS IN THE STOP	*
			;*  LOCATION AND NOT BEGIN THE JOG CYCLE.  WHEN	*
			;*  THE JOG MODE IS REQUESTED A FLAG IS SET TO	*
			;*  INDICATE THIS.  THIS ROUTINE WILL FIRST	*
			;*  CHECK THE JOG FLAG AND IF SET WILL THEN	*
			;*  COMPARE COUNTS.  WHEN THE COUNT COMPARES 	*
			;*  POSITIVE IT WILL SET THE STOP REQUEST FLAG	*
			;************************************************

	

JOGIT:	LD	A,(REG1)
	BIT	2,A		;IS THE JOG MODE FLAG SET
	RET	Z		;IF NOT RETURN TO PULSE
	LD	HL,(CURCNT)	;LOAD THE CURRENT COUNT FOR COMPARISON
	LD	DE,(JOGCNT)	;LOAD THE LOCATION COUNT FOR THE JOG OPERATION
	LD	A,D
	CP	H
	RET	NZ		;RETURN IF IT IS NOT TIME TO SET FOG STOP BIT
	LD	A,E
	CP	L
	RET	NZ		;RETURN IF IT IS NOT TIME TO SET JOG STOP BIT
	LD	A,(STPREG)
	SET	7,A		;SET THE STOP REQUEST FLAG
	LD	(STPREG),A
	RET

			;************************************************
			;*	THIS ROUTINE IS USED TO VERIFY THAT A 	*
			;*  PART HAS BEEN TESTED.  IF THERE IS NO PART	*
			;*  PRESENT IT WILL CLEAR THE SHIFT REGISTER    *
			;*  BIT AND CANCEL THE BAD PART EJECT.  IF THE	*
			;*  PART IS PRESENT IT WILL NOT AFFECT THE SHIFT*
			;*  REGISTER BIT.  IF THE PART IS NOT PRESENT	*
			;*  BUT THE SHIFT REGISTER INDICATES THE PART	*
			;*  WAS GOOD, AN ERROR FLAG AND INDICATOR LIGHT	*
			;*  ARE SET.					*
			;*  	THE ROUTINE WILL SET A CONDITION FLAG	*
			;*  THAT SHOWS THIS TEST WAS COMPLETE.  THIS 	*
			;*  FLAG IS USED TO ENTER THE PART EJECT ROUTINE*
			;************************************************
PARTIT:	LD	A,(RUNREG)
	BIT	4,A		;SEE IF THE BITS HAVE BEEN SHIFTED.
	RET	Z		;IF NOT, RETURN TO PULSE ROUTINE
	LD	HL,(CURCNT)
	LD	DE,(PARTCNT)	;LOAD THE LOCATION COUNT FOR THE PART VIEW
	LD	A,D
	CP	H		;CHECK THE LEAST SIG. BYTE
	RET	NZ		;RETURN IF THEY ARE NOT EQUAL
	LD	A,E
	CP	L		;CHECK THE MOST SIG. BYTE
	RET	NZ		;RETURN IF THEY ARE NOT EQUAL
	LD	A,(RUNREG)
	BIT	6,A		;SEE IF THE PART IS PRESENT
	JP	NZ,PRTHERE	;IF SO, JUMP TO SET COMPLETE BITS
	LD	A,(SHIFT2)	;CHECK,AT THE CUURENT SHIFTED LOCATION, IF THE
	BIT	7,A		;PART WAS GOOD OR BAD.  WHICH BIT WILL DEPEND 
	JP	Z,PARPROB	;IF GOOD AND NOT THERE, JUMP.
	LD	A,(SHIFT2)	;RESET THE ABOVE BIT. BAD PART WAS JUST AIR.
	RES	7,A		;THIS IS THE BIT
	LD	(SHIFT2),A
	JP	PRTHERE		;JUMP TO SET THE COMPLETE BITS

	LD	A,(ESIRLY)	;&&&&&&&&&&&&&&&PARPROB&&&&&&&&&&&&&&&&&&
	SET	7,A		;SET A BIT THAT SAYS PART TESTED GOOD BUT
	LD	(ESIRLY),A	;NO PART WAS PRESENT
	IN	A,01H
	SET	7,A		;TURN ON ERROR LED
	OUT 	01H,A
	LD	A,(STPREG)	;SET THE STP REQUEST TO STOP THE MACHINE
	SET	7,A
	LD	(STPREG),A
PARPROB:LD	A,(SHIFT2)
	SET	7,A		;SET THE PART SHIFT BIT AS BEING A BAD PART
	LD	(SHIFT2),A
PRTHERE:LD	A,(RUNREG)
	SET	5,A		;SET THE PART HERE TEST COMPLETED FLAG
	LD	(RUNREG),A
	LD	A,(RUNREG)
	RES	4,A		;RESET THE PARTS SHIFTED FLAG.
	RES	6,A		;RESET THE PART WAS HERE FLAG.
	LD	(RUNREG),A
	RET

			;****************************************
			;*     THIS ROUTINE LOADS A COUNT VALUE	*
			;* EVERY TIME A NEW PULSE IS RECEIVED	*
			;* THAT WILL BE DECREMENTED IN THE 10mS	*
			;* ROUTINE.  IF THE 10mS ROUTINE 	*
			;* DECREMENTS THE COUNT TO ZERO BEFORE	*
			;* THE NEXT PULSE RESETS IT THE OVEN 	*
			;* WILL AUTOMATICALLY SHUT OFF AND A 	*
			;* STOP REQUEST WILL BE SET.		*
			;****************************************


OVENP:	LD	A,(PORT06)
	BIT	5,A		;IS THE OVEN ON
	RET	Z		
	LD	HL,(SLOWDWN)	;IF SO, LOAD THE OVEN AUTO OFF DELAY COUNT
	INC	HL
	LD	(SLOWDWN),HL
	RET

	END